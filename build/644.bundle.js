/*! For license information please see 644.bundle.js.LICENSE.txt */
(self.webpackChunkplanet_pc=self.webpackChunkplanet_pc||[]).push([[644],{4184:(e,t)=>{var r;!function(){"use strict";var n={}.hasOwnProperty;function i(){for(var e=[],t=0;t<arguments.length;t++){var r=arguments[t];if(r){var a=typeof r;if("string"===a||"number"===a)e.push(r);else if(Array.isArray(r)){if(r.length){var s=i.apply(null,r);s&&e.push(s)}}else if("object"===a)if(r.toString===Object.prototype.toString)for(var c in r)n.call(r,c)&&r[c]&&e.push(c);else e.push(r.toString())}}return e.join(" ")}e.exports?(i.default=i,e.exports=i):void 0===(r=function(){return i}.apply(t,[]))||(e.exports=r)}()},8971:(e,t,r)=>{"use strict";r.d(t,{Z:()=>a});var n=r(3645),i=r.n(n)()((function(e){return e[1]}));i.push([e.id,"/*\n * @Author: liuxw@codoon.com \n * @Date: 2022-03-09 18:06:45 \n * @Last Modified by: liuxw@codoon.com\n * @Last Modified time: 2022-03-22 17:41:57\n */\n.ServiceWorkerPage {\n  margin: 80px 40px 0 40px;\n}\n.ServiceWorkerPage-text {\n  margin-bottom: 10px;\n}\n.ServiceWorkerPage-text.is-delete {\n  text-decoration: line-through;\n  color: #aaa;\n}\n.ServiceWorkerPage-text .is-italic {\n  font-style: italic;\n}\n.ServiceWorkerPage-text .is-bold {\n  font-weight: bold;\n}\n.ServiceWorkerPage-text .is-underline {\n  text-decoration: underline;\n}\n.ServiceWorkerPage-img {\n  width: 400px;\n}\n.ServiceWorkerPage-img img {\n  width: 100%;\n}\n",""]);const a=i},5644:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>p});const n=r.p+"assets/images/stardewValley.jpg";var i=r(7294),a=r(3379),s=r.n(a),c=r(8971);s()(c.Z,{insert:"head",singleton:!1}),c.Z.locals;var o=r(4184),l=r.n(o),m="ServiceWorkerPage";"serviceWorker"in navigator&&navigator.serviceWorker.register(window.location.pathname+"serviceWorker.js",{scope:window.location.pathname}).then((function(e){console.log("Registration succeeded. Scope is "+e.scope)})).catch((function(e){console.log("Registration failed with "+e)}));const p=(0,i.memo)((function(e){return i.createElement("div",{className:m},i.createElement("div",{className:m+"-text"},i.createElement("span",{className:"is-bold"},"1.")," 首次访问该页面，",i.createElement("span",{className:l()("is-italic","is-underline")},"会注册、并安装 Service Worker"),"。安装时将下图加入了缓存区"),i.createElement("div",{className:m+"-text"},i.createElement("span",{className:"is-bold"},"2.")," 刷新页面，会激活已安装的 Service Worker。",i.createElement("span",{className:l()("is-italic","is-underline")},"此时 Service Worker 才对页面有了控制权"),"。查看 Network 将发现，图片从 Service Worker 返回，没有网络请求"),i.createElement("div",{className:m+"-text"},i.createElement("span",{className:l()("is-italic","is-underline")},"事实上，在 Network 看到从 Service Worker 返回，并不能说明没有网络请求"),"。因为所有静态资源请求都会经过 Service Worker，这已经会在 Network 中显示为从 Service Worker 返回了"),i.createElement("div",{className:m+"-text"},"静态资源请求触发 Service Worker 的 fetch 事件后，Service Worker 将请求与缓存区比对。如果有缓存命中，直接返回缓存；如果没有，发起http请求，再返回请求到的结果"),i.createElement("div",{className:m+"-text"},"Application > Cache > Cache Storage 中可看见用于该页面名为v1的缓存区"),i.createElement("div",{className:l()(m+"-text","is-delete")},i.createElement("span",{className:"is-bold"},"3.")," ","断开网络，再次刷新页面，会发现页面能离线访问。这是因为，我们的 Service Worker 多做了一步，当拦截到没有缓存过的请求时，会将结果加入缓存，即现在所有的 js、css、img 静态资源都已被离线缓存"),i.createElement("div",{className:m+"-text"},i.createElement("span",{className:"is-bold"},"3.")," 接下来，还可以让 Service Worker 更聪明一点，当拦截到没有缓存过的资源时，自动将结果加入缓存。这样下次访问时，所有的静态资源都已被离线缓存，可实现完全的离线访问（该示例本来做了这一步，但已经删掉了；因为其它hash路由也属于当前scope，会被缓存，并不希望这样）"),i.createElement("div",{className:m+"-img"},i.createElement("img",{src:n})))}))}}]);